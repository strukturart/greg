{"id":"qiVg","dependencies":[{"name":"/home/strukturart/Desktop/Pages/greg/package.json","includedInParent":true,"mtime":1644931973019},{"name":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/package.json","includedInParent":true,"mtime":1644701756123},{"name":"./totext","loc":{"line":1,"column":19,"index":19},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/nlp/index.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/nlp/totext.js"},{"name":"./parsetext","loc":{"line":2,"column":22,"index":53},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/nlp/index.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/nlp/parsetext.js"},{"name":"../index","loc":{"line":3,"column":18,"index":86},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/nlp/index.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/index.js"},{"name":"./i18n","loc":{"line":4,"column":20,"index":118},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/nlp/index.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/nlp/i18n.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFullyConvertible = exports.fromText = void 0;\nObject.defineProperty(exports, \"parseText\", {\n  enumerable: true,\n  get: function () {\n    return _parsetext.default;\n  }\n});\nexports.toText = void 0;\n\nvar _totext = _interopRequireDefault(require(\"./totext\"));\n\nvar _parsetext = _interopRequireDefault(require(\"./parsetext\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _i18n = _interopRequireDefault(require(\"./i18n\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*!\n* rrule.js - Library for working with recurrence rules for calendar dates.\n* https://github.com/jakubroztocil/rrule\n*\n* Copyright 2010, Jakub Roztocil and Lars Schoning\n* Licenced under the BSD licence.\n* https://github.com/jakubroztocil/rrule/blob/master/LICENCE\n*\n*/\n\n/**\n *\n * Implementation of RRule.fromText() and RRule::toText().\n *\n *\n * On the client side, this file needs to be included\n * when those functions are used.\n *\n */\n// =============================================================================\n// fromText\n// =============================================================================\n\n/**\n * Will be able to convert some of the below described rules from\n * text format to a rule object.\n *\n *\n * RULES\n *\n * Every ([n])\n *       day(s)\n *     | [weekday], ..., (and) [weekday]\n *     | weekday(s)\n *     | week(s)\n *     | month(s)\n *     | [month], ..., (and) [month]\n *     | year(s)\n *\n *\n * Plus 0, 1, or multiple of these:\n *\n * on [weekday], ..., (or) [weekday] the [monthday], [monthday], ... (or) [monthday]\n *\n * on [weekday], ..., (and) [weekday]\n *\n * on the [monthday], [monthday], ... (and) [monthday] (day of the month)\n *\n * on the [nth-weekday], ..., (and) [nth-weekday] (of the month/year)\n *\n *\n * Plus 0 or 1 of these:\n *\n * for [n] time(s)\n *\n * until [date]\n *\n * Plus (.)\n *\n *\n * Definitely no supported for parsing:\n *\n * (for year):\n *     in week(s) [n], ..., (and) [n]\n *\n *     on the [yearday], ..., (and) [n] day of the year\n *     on day [yearday], ..., (and) [n]\n *\n *\n * NON-TERMINALS\n *\n * [n]: 1, 2 ..., one, two, three ..\n * [month]: January, February, March, April, May, ... December\n * [weekday]: Monday, ... Sunday\n * [nth-weekday]: first [weekday], 2nd [weekday], ... last [weekday], ...\n * [monthday]: first, 1., 2., 1st, 2nd, second, ... 31st, last day, 2nd last day, ..\n * [date]:\n *     [month] (0-31(,) ([year])),\n *     (the) 0-31.(1-12.([year])),\n *     (the) 0-31/(1-12/([year])),\n *     [weekday]\n *\n * [year]: 0000, 0001, ... 01, 02, ..\n *\n * Definitely not supported for parsing:\n *\n * [yearday]: first, 1., 2., 1st, 2nd, second, ... 366th, last day, 2nd last day, ..\n *\n * @param {String} text\n * @return {Object, Boolean} the rule, or null.\n */\nvar fromText = function (text, language) {\n  if (language === void 0) {\n    language = _i18n.default;\n  }\n\n  return new _index.default((0, _parsetext.default)(text, language) || undefined);\n};\n\nexports.fromText = fromText;\nvar common = ['count', 'until', 'interval', 'byweekday', 'bymonthday', 'bymonth'];\n_totext.default.IMPLEMENTED = [];\n_totext.default.IMPLEMENTED[_index.default.HOURLY] = common;\n_totext.default.IMPLEMENTED[_index.default.MINUTELY] = common;\n_totext.default.IMPLEMENTED[_index.default.DAILY] = ['byhour'].concat(common);\n_totext.default.IMPLEMENTED[_index.default.WEEKLY] = common;\n_totext.default.IMPLEMENTED[_index.default.MONTHLY] = common;\n_totext.default.IMPLEMENTED[_index.default.YEARLY] = ['byweekno', 'byyearday'].concat(common); // =============================================================================\n// Export\n// =============================================================================\n\nvar toText = function (rrule, gettext, language) {\n  return new _totext.default(rrule, gettext, language).toString();\n};\n\nexports.toText = toText;\nvar isFullyConvertible = _totext.default.isFullyConvertible;\nexports.isFullyConvertible = isFullyConvertible;"},"sourceMaps":null,"error":null,"hash":"7ad15b89e8f5acc0071f3690f8639af9","cacheData":{"env":{}}}