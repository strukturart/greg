{"id":"adWO","dependencies":[{"name":"/home/strukturart/Desktop/Pages/greg/package.json","includedInParent":true,"mtime":1644931973019},{"name":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/package.json","includedInParent":true,"mtime":1644701756123},{"name":"./dateutil","loc":{"line":1,"column":21,"index":21},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/dateutil.js"},{"name":"./iterinfo","loc":{"line":2,"column":21,"index":56},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/iterinfo.js"},{"name":"./helpers","loc":{"line":3,"column":53,"index":123},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/helpers.js"},{"name":"./iterresult","loc":{"line":4,"column":23,"index":159},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/iterresult.js"},{"name":"./callbackiterresult","loc":{"line":5,"column":31,"index":206},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/callbackiterresult.js"},{"name":"./types","loc":{"line":6,"column":26,"index":256},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/types.js"},{"name":"./parseoptions","loc":{"line":7,"column":48,"index":315},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/parseoptions.js"},{"name":"./parsestring","loc":{"line":8,"column":28,"index":361},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/parsestring.js"},{"name":"./optionstostring","loc":{"line":9,"column":32,"index":410},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/optionstostring.js"},{"name":"./cache","loc":{"line":10,"column":22,"index":453},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/cache.js"},{"name":"./weekday","loc":{"line":11,"column":24,"index":488},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/weekday.js"},{"name":"luxon","loc":{"line":12,"column":25,"index":526},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/luxon/build/cjs-browser/luxon.js"},{"name":"./nlp","loc":{"line":16,"column":30,"index":668},"parent":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/rrule.js","resolved":"/home/strukturart/Desktop/Pages/greg/node_modules/rrule/dist/esm/nlp/index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultKeys = exports.default = exports.Days = exports.DEFAULT_OPTIONS = void 0;\n\nvar _dateutil = _interopRequireDefault(require(\"./dateutil\"));\n\nvar _iterinfo = _interopRequireDefault(require(\"./iterinfo\"));\n\nvar _helpers = require(\"./helpers\");\n\nvar _iterresult = _interopRequireDefault(require(\"./iterresult\"));\n\nvar _callbackiterresult = _interopRequireDefault(require(\"./callbackiterresult\"));\n\nvar _types = require(\"./types\");\n\nvar _parseoptions = require(\"./parseoptions\");\n\nvar _parsestring = require(\"./parsestring\");\n\nvar _optionstostring = require(\"./optionstostring\");\n\nvar _cache = require(\"./cache\");\n\nvar _weekday = require(\"./weekday\");\n\nvar _luxon = require(\"luxon\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar getnlp = function () {\n  // Lazy, runtime import to avoid circular refs.\n  if (!getnlp._nlp) {\n    getnlp._nlp = require('./nlp');\n  }\n\n  return getnlp._nlp;\n}; // =============================================================================\n// RRule\n// =============================================================================\n\n\nvar Days = {\n  MO: new _weekday.Weekday(0),\n  TU: new _weekday.Weekday(1),\n  WE: new _weekday.Weekday(2),\n  TH: new _weekday.Weekday(3),\n  FR: new _weekday.Weekday(4),\n  SA: new _weekday.Weekday(5),\n  SU: new _weekday.Weekday(6)\n};\nexports.Days = Days;\nvar DEFAULT_OPTIONS = {\n  freq: _types.Frequency.YEARLY,\n  dtstart: null,\n  interval: 1,\n  wkst: Days.MO,\n  count: null,\n  until: null,\n  tzid: null,\n  bysetpos: null,\n  bymonth: null,\n  bymonthday: null,\n  bynmonthday: null,\n  byyearday: null,\n  byweekno: null,\n  byweekday: null,\n  bynweekday: null,\n  byhour: null,\n  byminute: null,\n  bysecond: null,\n  byeaster: null\n};\nexports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;\nvar defaultKeys = Object.keys(DEFAULT_OPTIONS);\n/**\n *\n * @param {Options?} options - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>\n *        The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...\n * @constructor\n */\n\nexports.defaultKeys = defaultKeys;\n\nvar RRule =\n/** @class */\nfunction () {\n  function RRule(options, noCache) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (noCache === void 0) {\n      noCache = false;\n    } // RFC string\n\n\n    this._string = null;\n    this._cache = noCache ? null : new _cache.Cache(); // used by toString()\n\n    this.origOptions = (0, _parseoptions.initializeOptions)(options);\n\n    var _a = (0, _parseoptions.parseOptions)(options),\n        parsedOptions = _a.parsedOptions,\n        timeset = _a.timeset;\n\n    this.options = parsedOptions;\n    this.timeset = timeset;\n  }\n\n  RRule.parseText = function (text, language) {\n    return getnlp().parseText(text, language);\n  };\n\n  RRule.fromText = function (text, language) {\n    return getnlp().fromText(text, language);\n  };\n\n  RRule.fromString = function (str) {\n    return new RRule(RRule.parseString(str) || undefined);\n  };\n\n  RRule.prototype._cacheGet = function (what, args) {\n    if (!this._cache) return false;\n    return this._cache._cacheGet(what, args);\n  };\n\n  RRule.prototype._cacheAdd = function (what, value, args) {\n    if (!this._cache) return;\n    return this._cache._cacheAdd(what, value, args);\n  };\n  /**\n   * @param {Function} iterator - optional function that will be called\n   *                   on each date that is added. It can return false\n   *                   to stop the iteration.\n   * @return Array containing all recurrences.\n   */\n\n\n  RRule.prototype.all = function (iterator) {\n    if (iterator) {\n      return this._iter(new _callbackiterresult.default('all', {}, iterator));\n    } else {\n      var result = this._cacheGet('all');\n\n      if (result === false) {\n        result = this._iter(new _iterresult.default('all', {}));\n\n        this._cacheAdd('all', result);\n      }\n\n      return result;\n    }\n  };\n  /**\n   * Returns all the occurrences of the rrule between after and before.\n   * The inc keyword defines what happens if after and/or before are\n   * themselves occurrences. With inc == True, they will be included in the\n   * list, if they are found in the recurrence set.\n   * @return Array\n   */\n\n\n  RRule.prototype.between = function (after, before, inc, iterator) {\n    if (inc === void 0) {\n      inc = false;\n    }\n\n    var args = {\n      before: before,\n      after: after,\n      inc: inc\n    };\n\n    if (iterator) {\n      return this._iter(new _callbackiterresult.default('between', args, iterator));\n    }\n\n    var result = this._cacheGet('between', args);\n\n    if (result === false) {\n      result = this._iter(new _iterresult.default('between', args));\n\n      this._cacheAdd('between', result, args);\n    }\n\n    return result;\n  };\n  /**\n   * Returns the last recurrence before the given datetime instance.\n   * The inc keyword defines what happens if dt is an occurrence.\n   * With inc == True, if dt itself is an occurrence, it will be returned.\n   * @return Date or null\n   */\n\n\n  RRule.prototype.before = function (dt, inc) {\n    if (inc === void 0) {\n      inc = false;\n    }\n\n    var args = {\n      dt: dt,\n      inc: inc\n    };\n\n    var result = this._cacheGet('before', args);\n\n    if (result === false) {\n      result = this._iter(new _iterresult.default('before', args));\n\n      this._cacheAdd('before', result, args);\n    }\n\n    return result;\n  };\n  /**\n   * Returns the first recurrence after the given datetime instance.\n   * The inc keyword defines what happens if dt is an occurrence.\n   * With inc == True, if dt itself is an occurrence, it will be returned.\n   * @return Date or null\n   */\n\n\n  RRule.prototype.after = function (dt, inc) {\n    if (inc === void 0) {\n      inc = false;\n    }\n\n    var args = {\n      dt: dt,\n      inc: inc\n    };\n\n    var result = this._cacheGet('after', args);\n\n    if (result === false) {\n      result = this._iter(new _iterresult.default('after', args));\n\n      this._cacheAdd('after', result, args);\n    }\n\n    return result;\n  };\n  /**\n   * Returns the number of recurrences in this set. It will have go trough\n   * the whole recurrence, if this hasn't been done before.\n   */\n\n\n  RRule.prototype.count = function () {\n    return this.all().length;\n  };\n  /**\n   * Converts the rrule into its string representation\n   * @see <http://www.ietf.org/rfc/rfc2445.txt>\n   * @return String\n   */\n\n\n  RRule.prototype.toString = function () {\n    return (0, _optionstostring.optionsToString)(this.origOptions);\n  };\n  /**\n   * Will convert all rules described in nlp:ToText\n   * to text.\n   */\n\n\n  RRule.prototype.toText = function (gettext, language) {\n    return getnlp().toText(this, gettext, language);\n  };\n\n  RRule.prototype.isFullyConvertibleToText = function () {\n    return getnlp().isFullyConvertible(this);\n  };\n  /**\n   * @return a RRule instance with the same freq and options\n   *          as this one (cache is not cloned)\n   */\n\n\n  RRule.prototype.clone = function () {\n    return new RRule(this.origOptions);\n  };\n\n  RRule.prototype._iter = function (iterResult) {\n    /* Since JavaScript doesn't have the python's yield operator (<1.7),\n        we use the IterResult object that tells us when to stop iterating.\n         */\n    var _a, _b;\n\n    var dtstart = this.options.dtstart;\n    var date = new _dateutil.default.DateTime(dtstart.getUTCFullYear(), dtstart.getUTCMonth() + 1, dtstart.getUTCDate(), dtstart.getUTCHours(), dtstart.getUTCMinutes(), dtstart.getUTCSeconds(), dtstart.valueOf() % 1000); // Some local variables to speed things up a bit\n\n    var _c = this.options,\n        freq = _c.freq,\n        interval = _c.interval,\n        wkst = _c.wkst,\n        until = _c.until,\n        bymonth = _c.bymonth,\n        byweekno = _c.byweekno,\n        byyearday = _c.byyearday,\n        byweekday = _c.byweekday,\n        byeaster = _c.byeaster,\n        bymonthday = _c.bymonthday,\n        bynmonthday = _c.bynmonthday,\n        bysetpos = _c.bysetpos,\n        byhour = _c.byhour,\n        byminute = _c.byminute,\n        bysecond = _c.bysecond;\n    var ii = new _iterinfo.default(this);\n    ii.rebuild(date.year, date.month);\n    var getdayset = (_a = {}, _a[RRule.YEARLY] = ii.ydayset, _a[RRule.MONTHLY] = ii.mdayset, _a[RRule.WEEKLY] = ii.wdayset, _a[RRule.DAILY] = ii.ddayset, _a[RRule.HOURLY] = ii.ddayset, _a[RRule.MINUTELY] = ii.ddayset, _a[RRule.SECONDLY] = ii.ddayset, _a)[freq];\n    var timeset;\n    var gettimeset;\n\n    if (freq < RRule.HOURLY) {\n      timeset = this.timeset;\n    } else {\n      gettimeset = (_b = {}, _b[RRule.HOURLY] = ii.htimeset, _b[RRule.MINUTELY] = ii.mtimeset, _b[RRule.SECONDLY] = ii.stimeset, _b)[freq];\n\n      if (freq >= RRule.HOURLY && (0, _helpers.notEmpty)(byhour) && !(0, _helpers.includes)(byhour, date.hour) || freq >= RRule.MINUTELY && (0, _helpers.notEmpty)(byminute) && !(0, _helpers.includes)(byminute, date.minute) || freq >= RRule.SECONDLY && (0, _helpers.notEmpty)(bysecond) && !(0, _helpers.includes)(bysecond, date.second)) {\n        timeset = [];\n      } else {\n        timeset = gettimeset.call(ii, date.hour, date.minute, date.second, date.millisecond);\n      }\n    }\n\n    var currentDay;\n    var count = this.options.count;\n    var pos;\n\n    while (true) {\n      // Get dayset with the right frequency\n      var _d = getdayset.call(ii, date.year, date.month, date.day),\n          dayset = _d[0],\n          start = _d[1],\n          end = _d[2]; // Do the \"hard\" work ;-)\n\n\n      var filtered = false;\n\n      for (var dayCounter = start; dayCounter < end; dayCounter++) {\n        currentDay = dayset[dayCounter];\n        filtered = isFiltered(bymonth, ii, currentDay, byweekno, byweekday, byeaster, bymonthday, bynmonthday, byyearday);\n        if (filtered) dayset[currentDay] = null;\n      } // Output results\n\n\n      if ((0, _helpers.notEmpty)(bysetpos) && (0, _helpers.notEmpty)(timeset)) {\n        var daypos = void 0;\n        var timepos = void 0;\n        var poslist = [];\n\n        for (var j = 0; j < bysetpos.length; j++) {\n          pos = bysetpos[j];\n\n          if (pos < 0) {\n            daypos = Math.floor(pos / timeset.length);\n            timepos = (0, _helpers.pymod)(pos, timeset.length);\n          } else {\n            daypos = Math.floor((pos - 1) / timeset.length);\n            timepos = (0, _helpers.pymod)(pos - 1, timeset.length);\n          }\n\n          var tmp = [];\n\n          for (var k = start; k < end; k++) {\n            var val = dayset[k];\n            if (!(0, _helpers.isPresent)(val)) continue;\n            tmp.push(val);\n          }\n\n          var i = void 0;\n\n          if (daypos < 0) {\n            // we're trying to emulate python's aList[-n]\n            i = tmp.slice(daypos)[0];\n          } else {\n            i = tmp[daypos];\n          }\n\n          var time = timeset[timepos];\n\n          var date_1 = _dateutil.default.fromOrdinal(ii.yearordinal + i);\n\n          var res = _dateutil.default.combine(date_1, time); // XXX: can this ever be in the array?\n          // - compare the actual date instead?\n\n\n          if (!(0, _helpers.includes)(poslist, res)) poslist.push(res);\n        }\n\n        _dateutil.default.sort(poslist);\n\n        for (var j = 0; j < poslist.length; j++) {\n          var res = poslist[j];\n\n          if (until && res > until) {\n            return this.emitResult(iterResult);\n          }\n\n          if (res >= dtstart) {\n            var rezonedDate = this.rezoneIfNeeded(res);\n\n            if (!iterResult.accept(rezonedDate)) {\n              return this.emitResult(iterResult);\n            }\n\n            if (count) {\n              --count;\n\n              if (!count) {\n                return this.emitResult(iterResult);\n              }\n            }\n          }\n        }\n      } else {\n        for (var j = start; j < end; j++) {\n          currentDay = dayset[j];\n\n          if (!(0, _helpers.isPresent)(currentDay)) {\n            continue;\n          }\n\n          var date_2 = _dateutil.default.fromOrdinal(ii.yearordinal + currentDay);\n\n          for (var k = 0; k < timeset.length; k++) {\n            var time = timeset[k];\n\n            var res = _dateutil.default.combine(date_2, time);\n\n            if (until && res > until) {\n              return this.emitResult(iterResult);\n            }\n\n            if (res >= dtstart) {\n              var rezonedDate = this.rezoneIfNeeded(res);\n\n              if (!iterResult.accept(rezonedDate)) {\n                return this.emitResult(iterResult);\n              }\n\n              if (count) {\n                --count;\n\n                if (!count) {\n                  return this.emitResult(iterResult);\n                }\n              }\n            }\n          }\n        }\n      } // Handle frequency and interval\n\n\n      if (freq === RRule.YEARLY) {\n        date.addYears(interval);\n      } else if (freq === RRule.MONTHLY) {\n        date.addMonths(interval);\n      } else if (freq === RRule.WEEKLY) {\n        date.addWeekly(interval, wkst);\n      } else if (freq === RRule.DAILY) {\n        date.addDaily(interval);\n      } else if (freq === RRule.HOURLY) {\n        date.addHours(interval, filtered, byhour); // @ts-ignore\n\n        timeset = gettimeset.call(ii, date.hour, date.minute, date.second);\n      } else if (freq === RRule.MINUTELY) {\n        if (date.addMinutes(interval, filtered, byhour, byminute)) {\n          filtered = false;\n        } // @ts-ignore\n\n\n        timeset = gettimeset.call(ii, date.hour, date.minute, date.second);\n      } else if (freq === RRule.SECONDLY) {\n        if (date.addSeconds(interval, filtered, byhour, byminute, bysecond)) {\n          filtered = false;\n        } // @ts-ignore\n\n\n        timeset = gettimeset.call(ii, date.hour, date.minute, date.second);\n      }\n\n      if (date.year > _dateutil.default.MAXYEAR) {\n        return this.emitResult(iterResult);\n      }\n\n      ii.rebuild(date.year, date.month);\n    }\n  };\n\n  RRule.prototype.emitResult = function (iterResult) {\n    this._len = iterResult.total;\n    return iterResult.getValue();\n  };\n\n  RRule.prototype.rezoneIfNeeded = function (date) {\n    var tzid = this.options.tzid;\n\n    if (!tzid) {\n      return date;\n    }\n\n    try {\n      var datetime = _luxon.DateTime.fromJSDate(date);\n\n      var rezoned = datetime.setZone(tzid, {\n        keepLocalTime: true\n      });\n      return rezoned.toJSDate();\n    } catch (e) {\n      if (e instanceof TypeError) {\n        console.error('Using TZID without Luxon available is unsupported. Returned times are in UTC, not the requested time zone');\n      }\n\n      return date;\n    }\n  }; // RRule class 'constants'\n\n\n  RRule.FREQUENCIES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY'];\n  RRule.YEARLY = _types.Frequency.YEARLY;\n  RRule.MONTHLY = _types.Frequency.MONTHLY;\n  RRule.WEEKLY = _types.Frequency.WEEKLY;\n  RRule.DAILY = _types.Frequency.DAILY;\n  RRule.HOURLY = _types.Frequency.HOURLY;\n  RRule.MINUTELY = _types.Frequency.MINUTELY;\n  RRule.SECONDLY = _types.Frequency.SECONDLY;\n  RRule.MO = Days.MO;\n  RRule.TU = Days.TU;\n  RRule.WE = Days.WE;\n  RRule.TH = Days.TH;\n  RRule.FR = Days.FR;\n  RRule.SA = Days.SA;\n  RRule.SU = Days.SU;\n  RRule.parseString = _parsestring.parseString;\n  RRule.optionsToString = _optionstostring.optionsToString;\n  return RRule;\n}();\n\nvar _default = RRule;\nexports.default = _default;\n\nfunction isFiltered(bymonth, ii, currentDay, byweekno, byweekday, byeaster, bymonthday, bynmonthday, byyearday) {\n  return (0, _helpers.notEmpty)(bymonth) && !(0, _helpers.includes)(bymonth, ii.mmask[currentDay]) || (0, _helpers.notEmpty)(byweekno) && !ii.wnomask[currentDay] || (0, _helpers.notEmpty)(byweekday) && !(0, _helpers.includes)(byweekday, ii.wdaymask[currentDay]) || (0, _helpers.notEmpty)(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !(0, _helpers.includes)(ii.eastermask, currentDay) || ((0, _helpers.notEmpty)(bymonthday) || (0, _helpers.notEmpty)(bynmonthday)) && !(0, _helpers.includes)(bymonthday, ii.mdaymask[currentDay]) && !(0, _helpers.includes)(bynmonthday, ii.nmdaymask[currentDay]) || (0, _helpers.notEmpty)(byyearday) && (currentDay < ii.yearlen && !(0, _helpers.includes)(byyearday, currentDay + 1) && !(0, _helpers.includes)(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !(0, _helpers.includes)(byyearday, currentDay + 1 - ii.yearlen) && !(0, _helpers.includes)(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));\n}"},"sourceMaps":null,"error":null,"hash":"838d2358604c9dd617aac7f6eba060e3","cacheData":{"env":{}}}